var documenterSearchIndex = {"docs":
[{"location":"man/dmstag/#DMStag","page":"DMStag","title":"DMStag","text":"","category":"section"},{"location":"man/dmstag/","page":"DMStag","title":"DMStag","text":"The following DMStag routines are available:","category":"page"},{"location":"man/dmstag/","page":"DMStag","title":"DMStag","text":"Modules = [PETSc]\nPages   = [\"dmstag.jl\"]","category":"page"},{"location":"man/vec/#Vec","page":"Vec","title":"Vec","text":"","category":"section"},{"location":"man/vec/","page":"Vec","title":"Vec","text":"The following Vec routines are available:","category":"page"},{"location":"man/vec/","page":"Vec","title":"Vec","text":"Modules = [PETSc]\nPages   = [\"vec.jl\"]","category":"page"},{"location":"man/mat/#Mat","page":"Mat","title":"Mat","text":"","category":"section"},{"location":"man/mat/","page":"Mat","title":"Mat","text":"The following Mat routines are available:","category":"page"},{"location":"man/mat/","page":"Mat","title":"Mat","text":"Modules = [PETSc]\nPages   = [\"mat.jl\"]","category":"page"},{"location":"man/snes/#SNES","page":"SNES","title":"SNES","text":"","category":"section"},{"location":"man/snes/","page":"SNES","title":"SNES","text":"The following SNES routines are available:","category":"page"},{"location":"man/snes/","page":"SNES","title":"SNES","text":"Modules = [PETSc]\nPages   = [\"snes.jl\"]","category":"page"},{"location":"man/ksp/#KSP","page":"KSP","title":"KSP","text":"","category":"section"},{"location":"man/ksp/","page":"KSP","title":"KSP","text":"The following KSP routines are available:","category":"page"},{"location":"man/ksp/","page":"KSP","title":"KSP","text":"Modules = [PETSc]\nPages   = [\"ksp.jl\"]","category":"page"},{"location":"man/ksp/#PETSc.KSP-Union{Tuple{PETSc.AbstractMat{PetscLib, PetscScalar} where PetscScalar}, Tuple{PetscLib}, Tuple{PETSc.AbstractMat{PetscLib, PetscScalar} where PetscScalar, PETSc.AbstractMat{PetscLib, PetscScalar} where PetscScalar}} where PetscLib","page":"KSP","title":"PETSc.KSP","text":"KSP(A::AbstractMat, P::AbstractMat{PetscLib} = A; options...)\n\nCreate a KSP using the matrix A and preconditioner construction matrix P with the options.\n\nThe communicator is obtained from A and if it has size 1 then the garbage collector is set, otherwise the user is responsible for calling destroy.\n\nExternal Links\n\nPETSc Manual: KSP/KSPCreate\n\nPETSc Manual: KSP/KSPSetOperators\n\nPETSc Manual: KSP/KSPSetFromOptions\n\n\n\n\n\n","category":"method"},{"location":"man/ksp/#PETSc.createvecs-Union{Tuple{PETSc.AbstractKSP{PetscLib, PetscScalar} where PetscScalar}, Tuple{PetscLib}} where PetscLib","page":"KSP","title":"PETSc.createvecs","text":"createvecs(ksp::AbstractKSP; nright = 0, nleft = 0)\n\nCreate nright right and nleft left vectors compatible with the ksp. Returned object V has Tuple members V.right and V.left containing the vectors.\n\nExternal Links\n\nPETSc Manual: KSP/KSPCreateVecs\n\n\n\n\n\n","category":"method"},{"location":"man/getting_started/#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Getting started\n1a. Installation using pre-build libraries\n1b. Installation using pre-build libraries\n2. Solving a linear system of equations\n3. Nonlinear example","category":"page"},{"location":"man/getting_started/#a.-Installation-using-pre-build-libraries","page":"Getting Started","title":"1a. Installation using pre-build libraries","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"The easiest way to install the package is: ","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ]\n(@v1.6) pkg> add https://github.com/JuliaParallel/PETSc.jl","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"which will install a pre-build PETSc library (PETSc_jll) as well as MPI.jl on your system. This will work both in serial and in parallel on your machine.","category":"page"},{"location":"man/getting_started/#b.-Installation-using-pre-build-libraries","page":"Getting Started","title":"1b. Installation using pre-build libraries","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"On many high-performance clusters, you will have to use the provided MPI installation for that cluster and the default download above will not be sufficient. Alternatively, you may be interested in a PETSc installation that comes with additional external packages. Ensure that this PETSc installation is compiled as a dynamic (and not a static) library, after which you need to set the environmental variable JULIA_PETSC_LIBRARY to link to your PETSc installation: ","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"$export JULIA_PETSC_LIBRARY = /path/to/your/petsc/installation:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Now rebuild the package:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ]\npkg> build PETSc","category":"page"},{"location":"man/getting_started/#.-Solving-a-linear-system-of-equations","page":"Getting Started","title":"2. Solving a linear system of equations","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Lets consider the following elliptic equation:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"beginaligned\npartial^2 T over partial x^2  = 0 T(0) = 1 T(1) = 11\nendaligned","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> using PETSc\njulia> n   =  11\njulia> Δx  =  1. / (n - 1)","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Let's first define the matrix with coefficients:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> nnz =  ones(Int32,n); nnz[2:n-1] .= 3;\njulia> A   =  PETSc.MatSeqAIJ{Float64}(n,n,nnz);\njulia> for i=2:n-1\n            A[i,i-1] =  1/Δx^2\n            A[i,i  ] = -2/Δx^2\n            A[i,i+1] =  1/Δx^2\n       end\n       A[1,1]=1; A[n,n]=1;\njulia> PETSc.assemble(A)\njulia> A\nMat Object: 1 MPI processes\n  type: seqaij\nrow 0: (0, 1.) \nrow 1: (0, 100.)  (1, -200.)  (2, 100.) \nrow 2: (1, 100.)  (2, -200.)  (3, 100.) \nrow 3: (2, 100.)  (3, -200.)  (4, 100.) \nrow 4: (3, 100.)  (4, -200.)  (5, 100.) \nrow 5: (4, 100.)  (5, -200.)  (6, 100.) \nrow 6: (5, 100.)  (6, -200.)  (7, 100.) \nrow 7: (6, 100.)  (7, -200.)  (8, 100.) \nrow 8: (7, 100.)  (8, -200.)  (9, 100.) \nrow 9: (8, 100.)  (9, -200.)  (10, 100.) \nrow 10: (10, 1.) ","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Now, lets define the right-hand-size vector rhs as a julia vector:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> rhs = zeros(n); rhs[1]=1; rhs[11]=11;","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Next, we define the linear solver for the matrix A, which is done by setting a KSP solver: ","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ksp = PETSc.KSP(A; ksp_rtol=1e-8, pc_type=\"jacobi\", ksp_monitor=true)","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Note that you can specify all PETSc command-line options as keywords here.","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Solving the system of equations is simple:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> sol = ksp\\rhs\n  0 KSP Residual norm 1.104536101719e+01 \n  1 KSP Residual norm 4.939635614091e+00 \n  2 KSP Residual norm 2.410295378065e+00 \n  3 KSP Residual norm 1.462993806273e+00 \n  4 KSP Residual norm 1.004123728835e+00 \n  5 KSP Residual norm 7.700861485629e-01 \n  6 KSP Residual norm 6.165623662013e-01 \n  7 KSP Residual norm 4.972507567923e-01 \n  8 KSP Residual norm 4.074986825669e-01 \n  9 KSP Residual norm 3.398492183940e-01 \n 10 KSP Residual norm 3.283015493450e-15 \n11-element Vector{Float64}:\n  1.0\n  2.000000000000001\n  3.0000000000000013\n  4.000000000000001\n  5.000000000000002\n  6.0\n  7.0000000000000036\n  8.000000000000002\n  9.000000000000004\n 10.000000000000002\n 11.0","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"And since we are using julia, plotting the solution can be done with","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> using Plots\njulia> plot(0:Δx:1,sol, ylabel=\"solution\",xlabel=\"x\")","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"(Image: linear_solution)","category":"page"},{"location":"man/getting_started/#.-Nonlinear-example","page":"Getting Started","title":"3. Nonlinear example","text":"","category":"section"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"Let's solve the coupled system of nonlinear equations: ","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"beginaligned\nx^2 + x y  = 3 \nx y + y^2  = 6\nendaligned","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"for x and y, which can be written in terms of a residual vector f:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"f = binom x^2 + x y  - 3 x y + y^2  - 6","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"In order to solve this, we need to provide a residual function that computes f:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> function F!(fx, x)\n         fx[1] = x[1]^2 + x[1]*x[2] - 3\n         fx[2] = x[1]*x[2] + x[2]^2 - 6\n       end","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"In addition, we need to provide the Jacobian:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"J = \nbeginpmatrix\nfracpartial f_1 partial x  fracpartial f_1 partial y  \nfracpartial f_2 partial x  fracpartial f_2 partial y  \nendpmatrix\n= \nbeginpmatrix\n2x + y  x  \ny  x + 2y  \nendpmatrix","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"In Julia, this is:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> function updateJ!(x, args...)\n            J[1,1] = 2x[1] + x[2]\n            J[1,2] = x[1]\n            J[2,1] = x[2]\n            J[2,2] = x[1] + 2x[2]\n        end","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"In order to solve this using the PETSc nonlinear equation solvers, you first define the SNES solver together with the jacobian and residual functions as ","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> using PETSc, MPI\njulia> S = PETSc.SNES{Float64}(MPI.COMM_SELF; ksp_rtol=1e-4, pc_type=\"none\")\njulia> PETSc.setfunction!(S, F!, PETSc.VecSeq(zeros(2)))\njulia> J = zeros(2,2)\njulia> PJ = PETSc.MatSeqDense(J)\njulia> PETSc.setjacobian!(S, updateJ!, PJ, PJ)","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"You can solve this as:","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> PETSc.solve!([2.0,3.0], S)\n2-element Vector{Float64}:\n 1.000000003259629\n 1.999999998137355","category":"page"},{"location":"man/getting_started/","page":"Getting Started","title":"Getting Started","text":"which indeed recovers the analytical solution (x=1 y=2).","category":"page"},{"location":"man/listfunctions/#List-of-all-functions","page":"List of functions","title":"List of all functions","text":"","category":"section"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"Here a summary of all functions:","category":"page"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"","category":"page"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"CurrentModule = PETSc","category":"page"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"Modules = [PETSc]","category":"page"},{"location":"man/listfunctions/#PETSc.AbstractOptions","page":"List of functions","title":"PETSc.AbstractOptions","text":"AbstractOptions{PetscLib <: PetscLibType}\n\nAbstract type of PETSc solver options.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.GlobalOptions","page":"List of functions","title":"PETSc.GlobalOptions","text":"GlobalOptions{PetscLib <: PetscLibType}\n\nThe PETSc global options database.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.MatAIJ","page":"List of functions","title":"PETSc.MatAIJ","text":"MatAIJ(\n    petsclib::PetscLib,\n    comm::MPI.Comm,\n    loc_num_rows::Integer,\n    loc_num_cols::Integer,\n    diag_nonzeros::Union{Integer, Vector},\n    off_diag_nonzeros::Union{Integer, Vector};\n    glo_num_rows = PETSC_DETERMINE,\n    glo_num_cols = PETSC_DETERMINE,\n    setup = true\n) where {PetscLib <: PetscLibType}\n\nCreate an MPI PETSc sparse array on the comm using AIJ format (also known as a compressed sparse row or CSR format) of size glo_num_rows X glo_num_cols with local size loc_num_rows X loc_num_cols.\n\nThe diagonal block and off-diagonal block non-zeros are diag_nonzeros and off_diag_nonzeros which can be either an integer (same for all rows) or a Vector of PetscInts with on entry per row.\n\nMemory allocation is handled by PETSc and garbage collection can be used.\n\nIf glo_num_rows isa Integer or glo_num_cols isa Integer then the corresponding local variable can be PETSC_DECIDE.\n\nIf setup == true then setup! is called\n\nExternal Links\n\nPETSc Manual: Mat/MatCreateAIJ\n\nPETSc Manual: Mat/MatSetUp\n\nnote: Note\nThe user is responsible for calling destroy(mat) on the MatAIJ since this cannot be handled by the garbage collector do to the MPI nature of the object.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.MatSeqAIJ","page":"List of functions","title":"PETSc.MatSeqAIJ","text":"MatSeqAIJ(petsclib, num_rows, num_cols, nonzeros)\n\nCreate a PETSc serial sparse array using AIJ format (also known as a compressed sparse row or CSR format) of size num_rows X num_cols with nonzeros per row\n\nIf nonzeros is an Integer the same number of non-zeros will be used for each row, if nonzeros is a Vector{PetscInt} then one value must be specified for each row.\n\nMemory allocation is handled by PETSc and garbage collection can be used.\n\nExternal Links\n\nPETSc Manual: Mat/MatCreateSeqAIJ\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.MatSeqDense","page":"List of functions","title":"PETSc.MatSeqDense","text":"MatSeqDense{PetscLib, PetscScalar}\n\nPETSc dense array. This wraps a Julia Matrix{PetscScalar} object.\n\nExternal Links\n\nPETSc Manual: Mat/MatCreateSeqDense\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.MatShell","page":"List of functions","title":"PETSc.MatShell","text":"MatShell(\n    petsclib::PetscLib,\n    obj::OType,\n    comm::MPI.Comm,\n    local_rows,\n    local_cols,\n    global_rows = LibPETSc.PETSC_DECIDE,\n    global_cols = LibPETSc.PETSC_DECIDE,\n)\n\nCreate a global_rows X global_cols PETSc shell matrix object wrapping obj with local size local_rows X local_cols.\n\nThe obj will be registered as an MATOP_MULT function and if if obj is a Function, then the multiply action obj(y,x); otherwise it calls mul!(y, obj, x).\n\nif comm == MPI.COMM_SELF then the garbage connector can finalize the object, otherwise the user is responsible for calling destroy.\n\nExternal Links\n\nPETSc Manual: Mat/MatCreateShell\n\nPETSc Manual: Mat/MatShellSetOperation\n\nPETSc Manual: Mat/MATOP_MULT\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.Options","page":"List of functions","title":"PETSc.Options","text":"Options{PetscLib <: PetscLibType}(kw -> arg, ...)\nOptions(petsclib, kw -> arg, ...)\n\nCreate a PETSc options data structure for the petsclib.\n\nFor construction a set of keyword argment pairs should be given. If the option has no value it should be set to nothing or true. Setting an option to false will cause the option not to be set on the PETSc options table.\n\nExamples\n\njulia> using PETSc\n\njulia> petsclib = PETSc.petsclibs[1];\n\njulia> PETSc.initialize(petsclib)\n\njulia> opt = PETSc.Options(\n                         petsclib,\n                         ksp_monitor = nothing,\n                         ksp_view = true,\n                         pc_type = \"mg\",\n                         pc_mg_levels = 1,\n                         false_opt = false,\n                     )\n#PETSc Option Table entries:\n-ksp_monitor\n-ksp_view\n-pc_mg_levels 1\n-pc_type mg\n#End of PETSc Option Table entries\n\n\njulia> opt[\"ksp_monitor\"]\n\"\"\n\njulia> opt[\"pc_type\"]\n\"mg\"\n\njulia> opt[\"pc_type\"] = \"ilu\"\n\"ilu\"\n\njulia> opt[\"pc_type\"]\n\"ilu\"\n\njulia> opt[\"false_opt\"]\nERROR: KeyError: key \"bad_key\" not found\n\njulia> opt[\"bad_key\"]\nERROR: KeyError: key \"bad_key\" not found\n\nExternal Links\n\nPETSc Manual: Sys/PetscOptionsCreate\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.VecGhost","page":"List of functions","title":"PETSc.VecGhost","text":"VecGhost(\n     petsclib,\n     comm:MPI.Comm,\n     local_length\n     ghost::Vector{PetscInt};\n     global_length = PETSC_DETERMINE,\n     num_ghost = length(ghost),\n)\n\nAn sequentially-stored MPI PETSc vector for petsclib.PetscScalar of local length local_length and global length global_length with ghost elements.\n\nIf global_length isa Int then local_length can be set to PETSC_DECIDE.\n\nExternal Links\n\nPETSc Manual: Vec/VecCreateGhost\n\nnote: Note\nThe user is responsible for calling destroy(vec) on the Vec since this cannot be handled by the garbage collector do to the MPI nature of the object.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.VecMPI","page":"List of functions","title":"PETSc.VecMPI","text":"VecMPI(\n     petsclib,\n     comm:MPI.Comm,\n     local_length;\n     global_length = PETSC_DETERMINE\n)\n\nAn sequentially-stored MPI PETSc vector for petsclib.PetscScalar of local length local_length and global length global_length without ghost elements.\n\nIf global_length isa Int then local_length can be set to PETSC_DECIDE in which case PETSc will decide the local_length.\n\nExternal Links\n\nPETSc Manual: Vec/VecCreateMPI\n\nnote: Note\nThe user is responsible for calling destroy(vec) on the Vec since this cannot be handled by the garbage collector do to the MPI nature of the object.\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.VecPtr","page":"List of functions","title":"PETSc.VecPtr","text":"VecPtr(petsclib, v::CVec, seq_finalize)\n\nContainer type for a PETSc Vec that is just a raw pointer.\n\nIf the seq_finalize and v points to a sequential vector, then finalizer will be set, otherwise the user is responsible for calling destroy (e.g., MPI vectors).\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.VecSeq","page":"List of functions","title":"PETSc.VecSeq","text":"VecSeq(petsclib, n::Int)\n\nA standard, sequentially-stored serial PETSc vector for petsclib.PetscScalar of length n.\n\nExternal Links\n\nPETSc Manual: Vec/VecCreateSeq\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.VecSeqWithArray","page":"List of functions","title":"PETSc.VecSeqWithArray","text":"VecSeqWithArray(petsclib, v::Vector)\n\nA standard, sequentially-stored serial PETSc vector, wrapping the Julia vector v.\n\nThis reuses the array v as storage, and so v should not be resize!-ed or otherwise have its length modified while the PETSc object exists.\n\nThis should only be need to be called for more advanced uses, for most simple usecases, users should be able to pass Vectors directly and have the wrapping performed automatically\n\nExternal Links\n\nPETSc Manual: Vec/VecCreateSeqWithArray\n\n\n\n\n\n","category":"type"},{"location":"man/listfunctions/#PETSc.assemble!","page":"List of functions","title":"PETSc.assemble!","text":"assemble!(M::AbstractMat[, t::MatAssemblyType = MAT_FINAL_ASSEMBLY)\n\nAssemble the matrix M with assembly type t.\n\nFor overlapping assembly see assemblybegin! and  assemblyend!\n\nExternal Links\n\nPETSc Manual: Mat/MatAssemblyBegin\n\nPETSc Manual: Mat/MatAssemblyEnd\n\n\n\n\n\n","category":"function"},{"location":"man/listfunctions/#PETSc.assemble!-Tuple{PETSc.AbstractVec}","page":"List of functions","title":"PETSc.assemble!","text":"assemble!(v::AbstractVec)\n\nAssemble the vector v.\n\nFor overlapping assembly see assemblybegin! and  assemblyend!\n\nExternal Links\n\nPETSc Manual: Vec/VecAssemblyBegin\n\nPETSc Manual: Vec/VecAssemblyEnd\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.assemblybegin!-Union{Tuple{PETSc.AbstractMat{PetscLib, PetscScalar} where PetscScalar}, Tuple{PetscLib}, Tuple{PETSc.AbstractMat{PetscLib, PetscScalar} where PetscScalar, PETSc.LibPETSc.MatAssemblyType}} where PetscLib","page":"List of functions","title":"PETSc.assemblybegin!","text":"assemblybegin!(M::AbstractMat[, t::MatAssemblyType = MAT_FINAL_ASSEMBLY)\n\nBegin assembly of the matrix M with assembly type t; finished with assemblyend!.\n\nExternal Links\n\nPETSc Manual: Mat/MatAssemblyBegin\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.assemblybegin!-Union{Tuple{PETSc.AbstractVec{PetscLib, PetscScalar} where PetscScalar}, Tuple{PetscLib}} where PetscLib","page":"List of functions","title":"PETSc.assemblybegin!","text":"assemblybegin!(vec::AbstractVec)\n\nBegin assembling vec\n\nExternal Links\n\nPETSc Manual: Vec/VecAssemblyBegin\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.assemblyend!-Union{Tuple{PETSc.AbstractMat{PetscLib, PetscScalar} where PetscScalar}, Tuple{PetscLib}, Tuple{PETSc.AbstractMat{PetscLib, PetscScalar} where PetscScalar, PETSc.LibPETSc.MatAssemblyType}} where PetscLib","page":"List of functions","title":"PETSc.assemblyend!","text":"assemblyend!(M::AbstractMat[, t::MatAssemblyType = MAT_FINAL_ASSEMBLY)\n\nFinish assembly of the matrix M with assembly type t; start assembly with assemblybegin!.\n\nExternal Links\n\nPETSc Manual: Mat/MatAssemblyEnd\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.assemblyend!-Union{Tuple{PETSc.AbstractVec{PetscLib, PetscScalar} where PetscScalar}, Tuple{PetscLib}} where PetscLib","page":"List of functions","title":"PETSc.assemblyend!","text":"assemblyend!(vec::AbstractVec)\n\nFinish assembling vec\n\nExternal Links\n\nPETSc Manual: Vec/VecAssemblyEnd\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.createvecs-Union{Tuple{PETSc.AbstractMat{PetscLib, PetscScalar} where PetscScalar}, Tuple{PetscLib}} where PetscLib","page":"List of functions","title":"PETSc.createvecs","text":"createvecs(\n    M::AbstractMat{PetscLib},\n)\n\nReturns vectors V which are compatible with M. A right compatible vectors is V.right and a left compatible vector is V.left; positionally these are returned as (right, left)\n\nThe created vectors are not garbage collected and should be destroyed with destroy.\n\nExternal Links\n\nPETSc Manual: Mat/MatCreateVecs\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.finalize-Tuple{}","page":"List of functions","title":"PETSc.finalize","text":"finalize(petsclib)\n\nFinalize the petsclib, if no petsclib is given then all PETSc.petsclibs will be finalized.\n\nExternal Links\n\nPETSc Manual: Sys/PetscFinalize\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.finalized-Tuple{Any}","page":"List of functions","title":"PETSc.finalized","text":"finalized(petsclib)\n\nCheck if petsclib is finalized\n\nExternal Links\n\nPETSc Manual: Sys/PetscFinalized\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.getlocalform-Union{Tuple{PETSc.AbstractVec{PetscLib, PetscScalar} where PetscScalar}, Tuple{PetscLib}} where PetscLib","page":"List of functions","title":"PETSc.getlocalform","text":"getlocalform(vec::AbstractVec)\n\nObtains the local ghosted representation of a Vec.\n\nnote: Note\nWhen done with the object the user should call restorelocalform!\n\nExternal Links\n\nPETSc Manual: Vec/VecGhostGetLocalForm\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.getpetsctype-Union{Tuple{PETSc.AbstractMat{PetscLib, PetscScalar} where PetscScalar}, Tuple{PetscLib}} where PetscLib","page":"List of functions","title":"PETSc.getpetsctype","text":"getpetsctype(mat::AbstractMat)\n\nreturn a string with the matrix type\n\nExternal Links\n\nPETSc Manual: Mat/MatGetType\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.getpetsctype-Union{Tuple{PETSc.AbstractVec{PetscLib, PetscScalar} where PetscScalar}, Tuple{PetscLib}} where PetscLib","page":"List of functions","title":"PETSc.getpetsctype","text":"getpetsctype(vec::AbstractVec)\n\nreturn a string with the vector type\n\nExternal Links\n\nPETSc Manual: Vec/VecGetType\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.getvalues!-Union{Tuple{PetscScalar}, Tuple{PetscInt}, Tuple{PetscLib}, Tuple{Array{PetscScalar, N} where N, PETSc.AbstractVec{PetscLib, PetscScalar} where PetscScalar, Vector{PetscInt}}} where {PetscLib, PetscInt, PetscScalar}","page":"List of functions","title":"PETSc.getvalues!","text":"getvalues!(\n    v::AbstractVec,\n    indices::Vector{PetscInt},\n    vals::Array{PetscScalar},\n)\n\nGet the 0-based global indices of vec into the preallocated array vals.\n\nwarning: Warning\nThis function uses 0-based indexing!\n\nExternal Links\n\nPETSc Manual: Vec/VecGetValues\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.ghostupdatebegin!-Union{Tuple{PETSc.AbstractVec{PetscLib, PetscScalar} where PetscScalar}, Tuple{PetscLib}, Tuple{PETSc.AbstractVec{PetscLib, PetscScalar} where PetscScalar, Any}, Tuple{PETSc.AbstractVec{PetscLib, PetscScalar} where PetscScalar, Any, Any}} where PetscLib","page":"List of functions","title":"PETSc.ghostupdatebegin!","text":"ghostupdatebegin!(\n    vec::AbstractVec,\n    insertmode = INSERT_VALUES,\n    scattermode = SCATTER_FORWARD,\n)\n\nBegins scattering vec to the local or global representations\n\nExternal Links\n\nPETSc Manual: Vec/VecGhostUpdateBegin\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.ghostupdateend!-Union{Tuple{PETSc.AbstractVec{PetscLib, PetscScalar} where PetscScalar}, Tuple{PetscLib}, Tuple{PETSc.AbstractVec{PetscLib, PetscScalar} where PetscScalar, Any}, Tuple{PETSc.AbstractVec{PetscLib, PetscScalar} where PetscScalar, Any, Any}} where PetscLib","page":"List of functions","title":"PETSc.ghostupdateend!","text":"ghostupdateend!(\n    vec::AbstractVec,\n    insertmode = INSERT_VALUES,\n    scattermode = SCATTER_FORWARD,\n)\n\nFinishes scattering vec to the local or global representations\n\nExternal Links\n\nPETSc Manual: Vec/VecGhostUpdateEnd\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.initialize-Tuple{}","page":"List of functions","title":"PETSc.initialize","text":"initialize([petsclib])\n\nInitialized the petsclib, if no petsclib is given then all PETSc.petsclibs will be initialized.\n\nAdditionally:\n\nThis will initialize MPI if it has not already been initialized.\nIt will disable the PETSc signal handler (via Sys/PetscPopSignalHandler\nAdd an atexit hook to call PETSc.finalize.\n\nExternal Links\n\nPETSc Manual: Sys/PetscInitializeNoArguments\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.initialized-Tuple{Any}","page":"List of functions","title":"PETSc.initialized","text":"initialized(petsclib)\n\nCheck if petsclib is initialized\n\nExternal Links\n\nPETSc Manual: Sys/PetscInitialized\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.ownershiprange-Union{Tuple{PETSc.AbstractMat{PetscLib, PetscScalar} where PetscScalar}, Tuple{PetscLib}, Tuple{PETSc.AbstractMat{PetscLib, PetscScalar} where PetscScalar, Bool}} where PetscLib","page":"List of functions","title":"PETSc.ownershiprange","text":"ownershiprange(mat::AbstractMat, [base_one = true])\n\nThe range of row indices owned by this processor, assuming that the mat is laid out with the first n1 rows on the first processor, next n2 rows on the second, etc. For certain parallel layouts this range may not be well defined.\n\nIf the optional argument base_one == true then base-1 indexing is used, otherwise base-0 index is used.\n\nnote: Note\nunlike the C function, the range returned is inclusive (idx_first:idx_last)\n\nExternal Links\n\nPETSc Manual: Mat/MatGetOwnershipRange\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.ownershiprange-Union{Tuple{PETSc.AbstractVec{PetscLib, PetscScalar} where PetscScalar}, Tuple{PetscLib}, Tuple{PETSc.AbstractVec{PetscLib, PetscScalar} where PetscScalar, Bool}} where PetscLib","page":"List of functions","title":"PETSc.ownershiprange","text":"ownershiprange(vec::AbstractVec, [base_one = true])\n\nThe range of indices owned by this processor, assuming that the vec is laid out with the first n1 elements on the first processor, next n2 elements on the second, etc. For certain parallel layouts this range may not be well defined.\n\nIf the optional argument base_one == true then base-1 indexing is used, otherwise base-0 index is used.\n\nnote: Note\nunlike the C function, the range returned is inclusive (idx_first:idx_last)\n\nExternal Links\n\nPETSc Manual: Vec/VecGetOwnershipRange\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.parse_options-Tuple{Vector{String}}","page":"List of functions","title":"PETSc.parse_options","text":"parse_options(args::Vector{String})\n\nParse the args vector into a NamedTuple that can be used as the options for the PETSc solvers.\n\njulia --project file.jl -ksp_monitor -pc_type mg -ksp_view\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.restorelocalform!-Union{Tuple{PETSc.LocalVec{PetscLib, PetscScalar, GVec} where {PetscScalar, GVec}}, Tuple{PetscLib}} where PetscLib","page":"List of functions","title":"PETSc.restorelocalform!","text":"restorelocalform!(local_vec::LocalVec)\n\nRestore the local_vec to the associated global vector after a call to getlocalform.\n\nExternal Links\n\nPETSc Manual: Vec/VecGhostRestoreLocalForm\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.setup!-Union{Tuple{PETSc.AbstractMat{PetscLib, PetscScalar} where PetscScalar}, Tuple{PetscLib}} where PetscLib","page":"List of functions","title":"PETSc.setup!","text":"setup!(mat::AbstractMat)\n\nSet up the interal data for mat\n\nExternal Links\n\nPETSc Manual: Mat/MatSetUp\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.setvalues!-Union{Tuple{PetscInt}, Tuple{PetscScalar}, Tuple{PetscLib}, Tuple{PETSc.AbstractMat{PetscLib, PetscScalar} where PetscScalar, Vector{PetscInt}, Vector{PetscInt}, Array{PetscScalar, N} where N}, Tuple{PETSc.AbstractMat{PetscLib, PetscScalar} where PetscScalar, Vector{PetscInt}, Vector{PetscInt}, Array{PetscScalar, N} where N, PETSc.LibPETSc.InsertMode}} where {PetscLib, PetscScalar, PetscInt}","page":"List of functions","title":"PETSc.setvalues!","text":"setvalues!(\n    M::AbstractMat{PetscLib},\n    row0idxs::Vector{PetscInt},\n    col0idxs::Vector{PetscInt},\n    rowvals::Array{PetscScalar},\n    insertmode::InsertMode = INSERT_VALUES;\n    num_rows = length(row0idxs),\n    num_cols = length(col0idxs)\n)\n\nSet values of the matrix M with base-0  row and column indices row0idxs and col0idxs inserting the values rowvals.\n\nIf the keyword arguments num_rows or num_cols is specified then only the first num_rows * num_cols values of rowvals will be used.\n\nExternal Links\n\nPETSc Manual: Mat/MatSetValues\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.setvalues!-Union{Tuple{PetscScalar}, Tuple{PetscInt}, Tuple{PetscLib}, Tuple{PETSc.AbstractVec{PetscLib, PetscScalar} where PetscScalar, Vector{PetscInt}, Array{PetscScalar, N} where N, PETSc.LibPETSc.InsertMode}} where {PetscLib, PetscInt, PetscScalar}","page":"List of functions","title":"PETSc.setvalues!","text":"setvalues!(\n    v::AbstractVec,\n    indices::Vector{PetscInt},\n    vals::Array{PetscScalar},\n    insertmode::InsertMode,\n)\n\nAssign the values vals in 0-based global indices of vec. The insertmode can be INSERT_VALUES or ADD_VALUES.\n\nwarning: Warning\nThis function uses 0-based indexing!\n\nExternal Links\n\nPETSc Manual: Vec/VecSetValues\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.unsafe_localarray-Union{Tuple{PETSc.AbstractVec{PetscLib, PetscScalar} where PetscScalar}, Tuple{PetscLib}} where PetscLib","page":"List of functions","title":"PETSc.unsafe_localarray","text":"unsafe_localarray(vec::AbstractVec; read=true, write=true)\n\nReturn an Array{PetscScalar} containing local portion of the PETSc vec\n\nUse read=false if the array is write-only; write=false if read-only.\n\nnote: Note\nBase.finalize should be called on the Array before the data can be used.\n\nExternal Links\n\nPETSc Manual: Vec/VecGetArray\n\nPETSc Manual: Vec/VecGetArrayWrite\n\nPETSc Manual: Vec/VecGetArrayRead\n\nPETSc Manual: Vec/VecRestoreArray\n\nPETSc Manual: Vec/VecRestoreArrayWrite\n\nPETSc Manual: Vec/VecRestoreArrayRead\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.with-Union{Tuple{PetscLib}, Tuple{Any, PETSc.Options{PetscLib}}} where PetscLib","page":"List of functions","title":"PETSc.with","text":"with(f, opts::Options)\n\nCall f() with the Options opts set temporarily (in addition to any global options).\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.withlocalarray!-Union{Tuple{N}, Tuple{Any, Tuple{Vararg{PETSc.AbstractVec, N}}}} where N","page":"List of functions","title":"PETSc.withlocalarray!","text":"withlocalarray!(f!, x::AbstractVec; read=true, write=true)\nwithlocalarray!(f!, xs...; read=true, write=true)\nwithlocalarray!(f!, xs::NTuple{N, AbstractVec}...; read=true, write=true)\n\nConvert x to an Array{PetscScalar} using unsafe_localarray and apply the function f!.\n\nUse read=false if the array is write-only; write=false if read-only.\n\nExamples\n\n```julia-repl julia> mapunsafelocalarray(x; write=true) do x    @. x .*= 2 end\n\nnote: Note\nBase.finalize is automatically called on the array.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/#PETSc.withlocalform-Tuple{Any, PETSc.AbstractVec}","page":"List of functions","title":"PETSc.withlocalform","text":"withlocalform(f::Function, vec::AbstractVec)\n\nConvert vec to a LocalVec and apply the function f!.\n\njulia> withlocalform(vec) do l_vec\n   # Do something with l_vec\nend\n\nnote: Note\nThis wrapper handles the calling of restorelocalform! before returning.\n\n\n\n\n\n","category":"method"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"Pages = [\"vec.md\", \"mat.md\"]","category":"page"},{"location":"man/listfunctions/","page":"List of functions","title":"List of functions","text":"Modules = [PETSc]\nOrder   = [:function]","category":"page"},{"location":"#PETSc.jl","page":"Home","title":"PETSc.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PETSc.jl is a Julia wrapper for the Portable, Extensible Toolkit for Scientific Computation PETSc package, which allows solving ordinary and partial differential equations in parallel on laptops or massively parallel high-performance systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The use of Julia greatly simplifies the code that developers have to write, while allowing to employ Julia features such as automatic differentiation. The Julia wrapper also comes with a pre-build library, which greatly simplifies the process of getting your first code working in parallel, on different operating systems. In many cases, the Julia code is significantly shorter than its C counterpart.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This wrapper mimics the PETSc-functionality as closely as possible, but remains work in progress (meaning that not everything has been translated yet). See the official user guide if you want to learn more about PETSc in general. For Julia-specific examples, have a look at our examples or tests. ","category":"page"},{"location":"man/design/#Design-notes","page":"Design notes","title":"Design notes","text":"","category":"section"},{"location":"man/design/","page":"Design notes","title":"Design notes","text":"PETSc can only be built for a single PetscScalar type. A workaround is to build multiple PETSc libraries for all supported scalar types (Float32, Float64, Complex{Float64})\nAppears that Complex{Float32} not supported (https://github.com/JuliaParallel/PETSc.jl/blob/old/deps/build_petscs.jl#L128).\nTODO: check if still the case\nshould be supported.\nNeed JLL support for this (https://github.com/JuliaPackaging/Yggdrasil/issues/1527)\nDefine macro to @eval all functions which use ccall for different scalar types.\nAll PETSc types and methods which involve ccall need a PetscScalar parameter.\nTODO: GPU support: need separate ones for CUDA as well?","category":"page"},{"location":"man/design/","page":"Design notes","title":"Design notes","text":"We lazily initialize each library if an object of that parameter is constructed.\nAlso initialize MPI if not already initialized\nWhat MPI thread level is required?\nnone.\nAdd atexit hook to finalize PETSc (this should be okay with MPI atexit, due to LIFO)\nDisable the PETSc signal handler","category":"page"},{"location":"man/design/","page":"Design notes","title":"Design notes","text":"A Julia object matching each PETSc object (Vec, Mat, KSP, etc.).\nThese will typically have a ptr as the first field, which lets us use the cconvert/unsafe_convert trick to pass pointer by value/reference.\nMost (all?) objects will have a comm field, for the MPI communicator\nObjects which wrap Julia objects will also need a reference to those objects to prevent GC.","category":"page"},{"location":"man/design/","page":"Design notes","title":"Design notes","text":"For convenience, attach finalizers to call destroy for single-process (\"sequential\") objects (VecSeq, MatSeqXXX, or any others where comm = MPI.COMM_SELF).\nWe can't attach finalizers for distributed objects (i.e. VecMPI), as destroy needs to be called collectively on all MPI ranks.\nSafe for users to call destroy manually if finalizer already defined\nTODO: check this with PETSc devs\nyes.\nUnclear how to handle objects that are contained within others, e.g. PC from KSPGetPC, KSP from SNESGetKSP, etc.\nThere appears to be some sort of reference counting, unclear if this is valid. PetscObjectReference / PetscObjectDereference\njust need to manually increment reference counter for these.\nFor PETSc objects which are equivalent to Julia objects (e.g. VecSeq : Vector{PetscScalar}, MatSeqDense : Matrix{PetscScalar}), use XXXCreateSeqWithArray methods so that they can share same memory.\nTODO: check PETSc guarantees on accessing the Julia objects directly.\nFor other objects (MatSeqAIJ), for now we let PETSc manage memory (may want to re-evaluate this later)\nDefine conversion routines to wrap with Seq objects where possible.\nDefine convenience versions of functions which take/return Julia Vectors, e.g. y = KSP(M) \\ x where y and x are Vectors.\nCan annotate PETSc objects with Julia ones via PetscContainerCreate & PetscObjectCompose\nFor specifying object options, there are 2 possible approaches:   (a) use PetscOptions objects (key-value pairs) to capture keyword args, which can be pushed and popped to the global options, then use XXXSetFromOption methods, e.g. KSP(mat, ksp_atol=1e-8)   (b) use C setter functions (e.g. KSPSetTolerances)\nfor now, we go with (a).\nit's easier\nnot all options are available via C setters, e.g. mg_coarse_XXX/mg_levels_XXX options\nideally we would create a more \"object-oriented\" interface: e.g. each preconditioner would be a different Julia type, but this doesn't yet seem possible.\ncan use PetscFunctionListGet to get runtime list of PC etc.","category":"page"},{"location":"man/design/","page":"Design notes","title":"Design notes","text":"For cases where PETSc needs to call Julia functions (MatShell, SNES), PETSc provides a mechanism to pass through a context pointer. We can use this to pass through a pointer to the object itself via pointer_from_objref.\nCan we pass NULL to vec/matrix args? What does that do?\nWhat should the callback interface look like?\nHow to handle errors from within callbacks?","category":"page"},{"location":"man/design/","page":"Design notes","title":"Design notes","text":"TODO: Error handling:\nhttps://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/PetscPushErrorHandler.html","category":"page"}]
}
